// StoryForge Database Schema
// PostgreSQL with Prisma ORM

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// USER & AUTHENTICATION
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  username      String    @unique
  passwordHash  String    @map("password_hash")
  displayName   String?   @map("display_name")
  avatarUrl     String?   @map("avatar_url")
  role          UserRole  @default(USER)
  status        UserStatus @default(ACTIVE)
  
  // Stats
  scenesCreated    Int @default(0) @map("scenes_created")
  segmentsCreated  Int @default(0) @map("segments_created")
  totalUpvotes     Int @default(0) @map("total_upvotes")
  
  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  lastLoginAt   DateTime? @map("last_login_at")
  
  // Relations
  scenes        Scene[]
  segments      Segment[]
  votes         Vote[]
  topics        Topic[]
  sessions      Session[]
  
  @@index([email])
  @@index([username])
  @@map("users")
}

enum UserRole {
  USER
  MODERATOR
  ADMIN
}

enum UserStatus {
  ACTIVE
  SUSPENDED
  DELETED
}

model Session {
  id           String   @id @default(cuid())
  userId       String   @map("user_id")
  refreshToken String   @unique @map("refresh_token")
  userAgent    String?  @map("user_agent")
  ipAddress    String?  @map("ip_address")
  expiresAt    DateTime @map("expires_at")
  createdAt    DateTime @default(now()) @map("created_at")
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([refreshToken])
  @@map("sessions")
}

// ============================================================================
// TOPICS
// ============================================================================

model Topic {
  id           String      @id @default(cuid())
  title        String
  description  String?
  category     String
  status       TopicStatus @default(OPEN)
  upvotes      Int         @default(0)
  sceneCount   Int         @default(0) @map("scene_count")
  
  // Creator
  createdById  String      @map("created_by_id")
  createdBy    User        @relation(fields: [createdById], references: [id])
  
  // Timestamps
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")
  
  // Relations
  scenes       Scene[]
  votes        Vote[]      @relation("TopicVotes")
  
  @@index([category])
  @@index([status])
  @@index([upvotes(sort: Desc)])
  @@map("topics")
}

enum TopicStatus {
  OPEN
  CLOSED
  ARCHIVED
}

// ============================================================================
// SCENES
// ============================================================================

model Scene {
  id             String      @id @default(cuid())
  title          String
  description    String?
  status         SceneStatus @default(DRAFT)
  thumbnailUrl   String?     @map("thumbnail_url")
  
  // Stats
  segmentCount   Int         @default(0) @map("segment_count")
  totalDuration  Float       @default(0) @map("total_duration")
  viewCount      Int         @default(0) @map("view_count")
  upvotes        Int         @default(0)
  
  // Relations
  topicId        String?     @map("topic_id")
  topic          Topic?      @relation(fields: [topicId], references: [id])
  
  createdById    String      @map("created_by_id")
  createdBy      User        @relation(fields: [createdById], references: [id])
  
  // Timestamps
  createdAt      DateTime    @default(now()) @map("created_at")
  updatedAt      DateTime    @updatedAt @map("updated_at")
  publishedAt    DateTime?   @map("published_at")
  
  // Relations
  segments       Segment[]
  bible          SceneBible?
  votes          Vote[]      @relation("SceneVotes")
  
  @@index([topicId])
  @@index([status])
  @@index([createdById])
  @@index([upvotes(sort: Desc)])
  @@map("scenes")
}

enum SceneStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
  MODERATION
}

// ============================================================================
// SCENE BIBLE (Continuity)
// ============================================================================

model SceneBible {
  id          String   @id @default(cuid())
  sceneId     String   @unique @map("scene_id")
  scene       Scene    @relation(fields: [sceneId], references: [id], onDelete: Cascade)
  
  // JSON data - see docs/05-continuity-system.md for structure
  characters  Json     @default("{}")
  locations   Json     @default("{}")
  objects     Json     @default("{}")
  timeline    Json     @default("[]")
  rules       Json     @default("{}")
  
  // Metadata
  version     Int      @default(1)
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")
  
  @@map("scene_bibles")
}

// ============================================================================
// SEGMENTS
// ============================================================================

model Segment {
  id             String        @id @default(cuid())
  sceneId        String        @map("scene_id")
  scene          Scene         @relation(fields: [sceneId], references: [id], onDelete: Cascade)
  
  // Content
  orderIndex     Int           @map("order_index")
  prompt         String
  expandedScript String?       @map("expanded_script")
  
  // Video
  status         SegmentStatus @default(PENDING)
  videoUrl       String?       @map("video_url")
  hlsUrl         String?       @map("hls_url")
  thumbnailUrl   String?       @map("thumbnail_url")
  duration       Float?
  
  // Metadata
  continuityHash String?       @map("continuity_hash")
  
  // Creator
  createdById    String        @map("created_by_id")
  createdBy      User          @relation(fields: [createdById], references: [id])
  
  // Timestamps
  createdAt      DateTime      @default(now()) @map("created_at")
  updatedAt      DateTime      @updatedAt @map("updated_at")
  completedAt    DateTime?     @map("completed_at")
  
  // Relations
  jobs           Job[]
  
  @@unique([sceneId, orderIndex])
  @@index([sceneId])
  @@index([status])
  @@index([createdById])
  @@map("segments")
}

enum SegmentStatus {
  PENDING
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
}

// ============================================================================
// JOBS (Async Processing)
// ============================================================================

model Job {
  id          String    @id @default(cuid())
  type        JobType
  status      JobStatus @default(PENDING)
  priority    Int       @default(0)
  
  // Relations
  segmentId   String?   @map("segment_id")
  segment     Segment?  @relation(fields: [segmentId], references: [id], onDelete: Cascade)
  
  // Progress
  progress    Int       @default(0)
  stage       String?
  
  // Results
  result      Json?
  error       String?
  
  // Retry tracking
  attempts    Int       @default(0)
  maxAttempts Int       @default(3) @map("max_attempts")
  
  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  startedAt   DateTime? @map("started_at")
  completedAt DateTime? @map("completed_at")
  
  @@index([status])
  @@index([segmentId])
  @@index([type, status])
  @@map("jobs")
}

enum JobType {
  GENERATE_SEGMENT
  REGENERATE_SEGMENT
  TRANSCODE_VIDEO
  GENERATE_THUMBNAIL
}

enum JobStatus {
  PENDING
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

// ============================================================================
// VOTES
// ============================================================================

model Vote {
  id        String   @id @default(cuid())
  value     Int      // 1 for upvote, -1 for downvote
  
  userId    String   @map("user_id")
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Polymorphic - either topic or scene
  topicId   String?  @map("topic_id")
  topic     Topic?   @relation("TopicVotes", fields: [topicId], references: [id], onDelete: Cascade)
  
  sceneId   String?  @map("scene_id")
  scene     Scene?   @relation("SceneVotes", fields: [sceneId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now()) @map("created_at")
  
  @@unique([userId, topicId])
  @@unique([userId, sceneId])
  @@index([topicId])
  @@index([sceneId])
  @@map("votes")
}

// ============================================================================
// MODERATION
// ============================================================================

model ModerationLog {
  id          String   @id @default(cuid())
  action      String   // flag, approve, reject, ban
  reason      String?
  
  // Target
  targetType  String   @map("target_type") // user, scene, segment, topic
  targetId    String   @map("target_id")
  
  // Moderator
  moderatorId String   @map("moderator_id")
  
  // Metadata
  metadata    Json?
  
  createdAt   DateTime @default(now()) @map("created_at")
  
  @@index([targetType, targetId])
  @@index([moderatorId])
  @@map("moderation_logs")
}
